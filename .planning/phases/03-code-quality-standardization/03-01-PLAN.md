---
phase: 03-code-quality-standardization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/domain/response.go
  - internal/helper/response.go
  - internal/app/server.go
  - internal/middleware/logging.go
  - internal/logger/logger.go
  - internal/logger/logger_coverage_test.go
  - internal/middleware/logging_test.go
  - internal/app/server_test.go
  - config/config.go
autonomous: true

must_haves:
  truths:
    - "zerolog and fiberzerolog are installed as Go module dependencies"
    - "Server starts with zerolog-based structured logging (JSON in production, console in development)"
    - "HTTP request logging is handled by fiberzerolog middleware, not the custom internal/logger package"
    - "The internal/logger/ package directory no longer exists"
    - "API responses use {status: 'success'/'error', code: N, message: '...'} envelope format"
    - "All existing tests pass after the changes"
  artifacts:
    - path: "internal/app/server.go"
      provides: "Zerolog initialization and fiberzerolog middleware wiring"
      contains: "github.com/rs/zerolog"
    - path: "internal/domain/response.go"
      provides: "Updated BaseResponse with Status string field"
      contains: "Status string"
    - path: "internal/helper/response.go"
      provides: "Updated response helpers using Status field"
      contains: "Status:"
  key_links:
    - from: "internal/app/server.go"
      to: "github.com/rs/zerolog"
      via: "zerolog.New() initialization"
      pattern: "zerolog\\.New"
    - from: "internal/app/server.go"
      to: "github.com/gofiber/contrib/fiberzerolog"
      via: "app.Use(fiberzerolog.New(...))"
      pattern: "fiberzerolog\\.New"
    - from: "internal/helper/response.go"
      to: "internal/domain/response.go"
      via: "domain.BaseResponse with Status field"
      pattern: "Status:\\s+\"(success|error)\""
---

<objective>
Install zerolog and fiberzerolog, create zerolog initialization, replace the custom internal/logger package and middleware/logging.go with zerolog-based equivalents, and update the API response envelope from `success: bool` to `status: string`.

Purpose: Establish the zerolog foundation that all subsequent logging migration depends on, and align the response envelope with the user's specified format. These are the two core infrastructure changes for the phase.
Output: Working zerolog-based logging in server.go, fiberzerolog HTTP request middleware, updated response envelope, deleted internal/logger package.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-quality-standardization/03-RESEARCH.md
@.planning/phases/03-code-quality-standardization/03-CONTEXT.md
@internal/app/server.go
@internal/logger/logger.go
@internal/middleware/logging.go
@internal/domain/response.go
@internal/helper/response.go
@config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install zerolog, update response envelope, and create zerolog initialization</name>
  <files>
    go.mod
    go.sum
    internal/domain/response.go
    internal/helper/response.go
    config/config.go
  </files>
  <action>
1. Install zerolog and fiberzerolog dependencies:
   ```
   go get github.com/rs/zerolog
   go get github.com/gofiber/contrib/fiberzerolog
   ```

2. Update `internal/domain/response.go`:
   - Change `BaseResponse.Success bool` field to `Status string` with JSON tag `json:"status"`
   - Keep `Message string` and `Code int` fields unchanged
   - Keep all other types (SuccessResponse, ErrorResponse, PaginationData, ListData, ValidationError) unchanged

3. Update `internal/helper/response.go`:
   - In `SendSuccessResponse`: change `Success: true` to `Status: "success"`
   - In `SendErrorResponse`: change `Success: false` to `Status: "error"`
   - All other functions remain unchanged (they delegate to SendSuccessResponse/SendErrorResponse)

4. In `config/config.go`: Add a `LOG_ENV` or use the existing `APP_ENV` value for zerolog format toggling. The existing `LoggingConfig` struct already has `Level` and `Format` fields -- keep them. Replace the single `log.Println` call (if present for .env warning) with a simple `fmt.Fprintf(os.Stderr, ...)` since config loads before logger initialization.

Run `go build ./...` after each file change to verify compilation.
  </action>
  <verify>
    `go build ./...` compiles without errors. `grep -r "Success.*bool" internal/domain/response.go` returns no matches (field renamed). `grep "Status.*string" internal/domain/response.go` returns the new field.
  </verify>
  <done>
    zerolog and fiberzerolog appear in go.mod. BaseResponse uses `Status string` instead of `Success bool`. Response helpers set `Status: "success"` or `Status: "error"`. Config file has no stdlib log imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace internal/logger and middleware/logging with zerolog in server.go</name>
  <files>
    internal/app/server.go
    internal/middleware/logging.go
    internal/logger/logger.go
    internal/logger/logger_coverage_test.go
    internal/middleware/logging_test.go
    internal/app/server_test.go
  </files>
  <action>
1. Create a zerolog initialization function directly in `internal/app/server.go` (or a small helper near the top):
   ```go
   func initLogger(env, level string) zerolog.Logger {
       var output io.Writer
       if env == "development" {
           output = zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: "15:04:05"}
       } else {
           output = os.Stderr
       }
       lvl, err := zerolog.ParseLevel(strings.ToLower(level))
       if err != nil {
           lvl = zerolog.ErrorLevel  // production default per user decision
       }
       return zerolog.New(output).Level(lvl).With().Timestamp().Str("service", "invento-service").Logger()
   }
   ```

2. Update `NewServer()` in `internal/app/server.go`:
   - Remove import of `"invento-service/internal/logger"`
   - Remove import of `"invento-service/internal/middleware"` for `RequestLogger` (keep for `RequestID` and `GetRequestID`)
   - Replace the old logger initialization block (lines 28-36) with `appLogger := initLogger(cfg.App.Env, cfg.Logging.Level)`
   - Replace `middleware.RequestLogger(appLogger)` with fiberzerolog middleware:
     ```go
     app.Use(fiberzerolog.New(fiberzerolog.Config{
         Logger: &appLogger,
         SkipURIs: []string{"/health", "/uploads"},
     }))
     ```
   - Update the ErrorHandler: replace `appLogger.WithRequestID(...)` and `appLogger.Error(...)` with zerolog calls:
     ```go
     appLogger.Error().Str("path", c.Path()).Str("method", c.Method()).Err(err).Msg("unhandled error")
     ```
   - Update the error handler's `fiber.Map` response to use `"status": "error"` instead of `"success": false` for the 404 case
   - Replace `appLogger.Info("Server starting", map[string]interface{}{...})` with zerolog:
     ```go
     appLogger.Info().Str("app", cfg.App.Name).Str("env", cfg.App.Env).Str("port", cfg.App.Port).Msg("server starting")
     ```
   - Replace `appLogger.Info("Swagger UI enabled...", nil)` with `appLogger.Info().Msg("swagger UI enabled")`

3. Delete `internal/middleware/logging.go` entirely -- its functionality is replaced by fiberzerolog.

4. Delete the entire `internal/logger/` directory (both `logger.go` and `logger_coverage_test.go`).

5. Update `internal/middleware/logging_test.go`: Remove tests for the deleted `RequestLogger`/`RequestLoggerWithConfig` functions. If the file only tests logging middleware, delete it. If it tests other middleware functions (like `RequestID`), keep only those tests.

6. Update `internal/app/server_test.go`: Fix any imports of `internal/logger`. Update test assertions that check for `"success"` bool to check for `"status"` string. Fix any compilation errors from the logger removal.

7. Check `internal/middleware/integration_test.go` and `internal/integration_test.go` for references to deleted logger -- fix any broken imports.

Run `go build ./...` after deleting each file. Run `go test ./...` at the end.
  </action>
  <verify>
    `go build ./...` compiles. `go test ./...` passes. `ls internal/logger/` fails (directory deleted). `grep -r "internal/logger" --include="*.go" .` returns no matches. `grep -r "middleware.RequestLogger" --include="*.go" .` returns no matches.
  </verify>
  <done>
    Server uses zerolog for all logging. fiberzerolog middleware handles HTTP request logging. The `internal/logger/` package is deleted. The `internal/middleware/logging.go` file is deleted. All tests pass. Error handler uses `"status": "error"` envelope format.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./...` passes (all existing tests)
3. `grep -rn "internal/logger" --include="*.go" .` returns zero matches
4. `grep -rn "middleware.RequestLogger" --include="*.go" .` returns zero matches
5. `grep -rn "Success.*bool" internal/domain/response.go` returns zero matches
6. `grep "zerolog" go.mod` shows both `rs/zerolog` and `gofiber/contrib/fiberzerolog`
</verification>

<success_criteria>
- zerolog is the sole logging library used in server.go
- fiberzerolog provides HTTP request/response logging middleware
- The custom internal/logger package no longer exists
- API response envelope uses `status: "success"/"error"` (string) instead of `success: true/false` (bool)
- All tests compile and pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-quality-standardization/03-01-SUMMARY.md`
</output>
