---
phase: 03-code-quality-standardization
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - main.go
  - cmd/app/main.go
  - config/database.go
  - internal/helper/tus_cleanup.go
  - internal/helper/tus_manager.go
  - internal/helper/middleware.go
  - internal/helper/logger.go
  - internal/usecase/tus_upload_usecase.go
  - internal/usecase/project_usecase.go
  - internal/usecase/repo/modul_repository.go
  - internal/usecase/auth_usecase.go
  - internal/controller/http/auth_controller.go
  - internal/middleware/requestid.go
  - internal/controller/http/auth_controller_test.go
  - internal/controller/http/user_controller_test.go
  - internal/controller/http/project_controller_test.go
  - internal/controller/http/modul_controller_test.go
  - internal/controller/http/tus_controller_test.go
  - internal/controller/http/role_controller_test.go
  - internal/controller/http/health_controller_test.go
  - internal/controller/http/statistic_controller_test.go
  - internal/integration_test.go
  - internal/middleware/integration_test.go
autonomous: true

must_haves:
  truths:
    - "Zero stdlib log.Printf/log.Println/log.Fatalf calls remain in non-test Go files"
    - "The file internal/helper/logger.go no longer exists"
    - "helper.NewLogger() is not used anywhere in the codebase"
    - "main.go uses zerolog for startup/shutdown logging"
    - "TusCleanup accepts a zerolog.Logger and uses it for all logging (17+ call sites replaced)"
    - "All test assertions match the new response envelope (status string instead of success bool)"
    - "go test ./... passes with zero failures"
  artifacts:
    - path: "main.go"
      provides: "Zerolog-based startup and shutdown logging"
      contains: "github.com/rs/zerolog"
    - path: "internal/helper/tus_cleanup.go"
      provides: "TusCleanup struct with zerolog.Logger field"
      contains: "zerolog.Logger"
    - path: "config/database.go"
      provides: "Database connection logging via zerolog"
      contains: "zerolog"
  key_links:
    - from: "main.go"
      to: "zerolog"
      via: "zerolog.New for pre-config fatal logging"
      pattern: "zerolog\\.(New|Fatal)"
    - from: "internal/helper/tus_cleanup.go"
      to: "zerolog"
      via: "tc.logger.Error/Info/Debug calls"
      pattern: "tc\\.logger\\.(Error|Info|Debug)"
    - from: "internal/app/server.go"
      to: "internal/helper/tus_cleanup.go"
      via: "NewTusCleanup now accepts zerolog.Logger"
      pattern: "NewTusCleanup.*zerolog"
---

<objective>
Complete the logging migration by replacing all remaining stdlib `log.*` calls with zerolog across the entire codebase, deleting `internal/helper/logger.go`, and updating all test assertions to match the new response envelope format.

Purpose: Achieve zero stdlib log usage (requirement LOG-01), remove the second custom logger package (GC pressure from helper.Logger), and ensure all tests validate the correct `status` field instead of the old `success` field.
Output: Zero stdlib log calls in production code. helper/logger.go deleted. All tests pass with new envelope assertions.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-quality-standardization/03-RESEARCH.md
@.planning/phases/03-code-quality-standardization/03-CONTEXT.md
@.planning/phases/03-code-quality-standardization/03-01-SUMMARY.md
@.planning/phases/03-code-quality-standardization/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace all stdlib log calls with zerolog across production code and delete helper/logger.go</name>
  <files>
    main.go
    cmd/app/main.go
    config/database.go
    internal/helper/tus_cleanup.go
    internal/helper/tus_manager.go
    internal/helper/middleware.go
    internal/helper/logger.go
    internal/usecase/tus_upload_usecase.go
    internal/usecase/project_usecase.go
    internal/usecase/repo/modul_repository.go
    internal/usecase/auth_usecase.go
    internal/controller/http/auth_controller.go
    internal/app/server.go
  </files>
  <action>
Replace log calls file-by-file. Run `go build ./...` after EACH file. Never batch.

**1. main.go** (5 calls):
- Replace `log.Fatalf("config load failed: %v", err)` with:
  ```go
  zerolog.New(os.Stderr).With().Timestamp().Logger().Fatal().Err(err).Msg("config load failed")
  ```
  Use zerolog directly since logger is not yet initialized at this point.
- Same pattern for `config validation failed`, `database connection failed`, `server init failed`
- Replace `log.Printf("server listen error: %v", err)` with zerolog Error call
- Replace `log.Println("server stopped gracefully")` with zerolog Info call
- After server init, create logger using the `initLogger` function from Plan 01's server.go, or use a simple zerolog instance for lifecycle messages
- Remove `"log"` import, add `"github.com/rs/zerolog"` and `"os"`

**2. cmd/app/main.go** (5 calls):
- Same changes as main.go (this is a duplicate entry point)

**3. config/database.go** (3 calls):
- These log database connection info. Since config loads before the application logger, pass a `zerolog.Logger` parameter to `ConnectDatabase()` or use `zerolog/log` package global for startup messages.
- Recommended approach: Add a `logger zerolog.Logger` parameter to `ConnectDatabase(cfg *Config, logger zerolog.Logger)`. Update callers in `main.go` and `cmd/app/main.go`.
- Replace `log.Printf("Connecting to database...")` with `logger.Info().Str("host", cfg.Database.Host).Msg("connecting to database")`
- Remove `"log"` import

**4. internal/helper/tus_cleanup.go** (17 calls -- largest file):
- Add a `logger zerolog.Logger` field to the `TusCleanup` struct
- Update `NewTusCleanup(...)` to accept a `zerolog.Logger` parameter. Create a sub-logger: `logger: logger.With().Str("component", "TusCleanup").Logger()`
- Update the caller in `internal/app/server.go`: pass `appLogger` to `NewTusCleanup`
- Replace all 17 `log.Printf`/`log.Println` calls with zerolog equivalents:
  - `log.Println("TusCleanup: ...")` -> `tc.logger.Info().Msg("...")`
  - `log.Printf("TusCleanup: error ...: %v", err)` -> `tc.logger.Error().Err(err).Msg("...")`
  - `log.Printf("TusCleanup: ... %d ...", count)` -> `tc.logger.Info().Int("count", count).Msg("...")`
- Remove `"log"` import

**5. internal/helper/tus_manager.go** (1 call):
- Add a `logger zerolog.Logger` field to `TusManager` struct (or accept it in constructor)
- Replace the single `log.Printf` with zerolog
- Update `NewTusManager(...)` signature and caller in `server.go`

**6. internal/helper/middleware.go** (1 call):
- The `RBACMiddleware` has a `log.Printf` for RBAC errors
- Since middleware functions don't have a logger field, use zerolog global `log` package: `import zlog "github.com/rs/zerolog/log"` then `zlog.Error().Err(err).Msg("RBAC check failed")`
- This is acceptable per research: "For packages like middleware that run in request context, using zerolog/log global is acceptable"
- Remove `"log"` import

**7. internal/usecase/tus_upload_usecase.go** (2 calls):
- Add a `logger zerolog.Logger` field to the usecase struct
- Update constructor and caller in `server.go`
- Replace `log.Printf` calls with zerolog
- Remove `"log"` import

**8. internal/usecase/project_usecase.go** (2 calls):
- Same pattern as tus_upload_usecase: add logger field, update constructor, replace calls
- Remove `"log"` import

**9. internal/usecase/repo/modul_repository.go** (2 calls):
- These are query error log calls. Add a `logger zerolog.Logger` field to the repository struct, or use zerolog global since repos are low-level.
- Recommended: Add logger field, update `NewModulRepository(db, logger)`, update caller in `server.go`
- Replace `log.Printf` calls with zerolog
- Remove `"log"` import

**10. internal/controller/http/auth_controller.go** and **internal/usecase/auth_usecase.go**:
- These use `helper.NewLogger()` from `internal/helper/logger.go`
- Replace `helper.NewLogger()` usage with zerolog (add logger field to struct, pass from constructor)
- Replace `.Warn(...)` and `.Error(...)` calls with zerolog equivalents
- Remove import of helper for logger (keep other helper imports)

**11. Delete `internal/helper/logger.go`** entirely (71 lines). This is the second custom logger that wraps stdlib log.

**12. Update `internal/app/server.go`** to pass `appLogger` to all updated constructors:
- `NewTusCleanup(..., appLogger)`
- `NewTusManager(..., appLogger)` (for both project and modul managers)
- `NewTusUploadUsecase(..., appLogger)`
- `NewProjectUsecase(..., appLogger)`
- `NewModulRepository(db, appLogger)`
- `NewAuthUsecase(..., appLogger)` or pass sub-logger
- `NewAuthController(..., appLogger)`
- `config.ConnectDatabase(cfg, appLogger)` -- update main.go callers too

After ALL replacements, verify: `grep -rn "\"log\"" --include="*.go" . | grep -v "_test.go" | grep -v vendor` should return zero matches (no stdlib log imports in production code).
  </action>
  <verify>
    `go build ./...` compiles. `grep -rn '"log"' --include="*.go" . | grep -v _test.go | grep -v vendor | grep -v "zerolog"` returns zero matches (no stdlib log in production code). `ls internal/helper/logger.go` fails (deleted). `grep -rn "helper\.NewLogger\|helper\.Logger" --include="*.go" . | grep -v _test.go` returns zero matches.
  </verify>
  <done>
    Zero stdlib `log` package imports remain in production Go files. `internal/helper/logger.go` is deleted. All components receive zerolog.Logger via dependency injection. TusCleanup, TusManager, usecases, and repositories use zerolog for structured logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all test assertions for response envelope change and fix broken test imports</name>
  <files>
    internal/controller/http/auth_controller_test.go
    internal/controller/http/user_controller_test.go
    internal/controller/http/project_controller_test.go
    internal/controller/http/modul_controller_test.go
    internal/controller/http/tus_controller_test.go
    internal/controller/http/role_controller_test.go
    internal/controller/http/health_controller_test.go
    internal/controller/http/statistic_controller_test.go
    internal/integration_test.go
    internal/middleware/integration_test.go
  </files>
  <action>
**Response envelope test assertions:**

In Plan 01, we changed `BaseResponse.Success bool` to `BaseResponse.Status string`. All test files that assert on the response body need updating.

For each test file:
1. Search for assertions checking `"success"` as a boolean:
   - `"success": true` -> `"status": "success"`
   - `"success": false` -> `"status": "error"`
   - `assert.*success.*true` -> update to check `status == "success"`
   - Any JSON unmarshaling that reads a `Success bool` field -> update to `Status string`
2. If tests use struct-based assertion (unmarshaling into `domain.SuccessResponse` or `domain.ErrorResponse`), the struct field change handles it automatically -- just verify the field name in assertions
3. If tests use raw JSON comparison (`map[string]interface{}`), update the key from `"success"` to `"status"` and value from `true`/`false` to `"success"`/`"error"`

**Broken imports from deleted packages:**

1. Check all test files for imports of `"invento-service/internal/logger"` -- remove these imports and fix any test code that used the logger
2. Check for imports of helper.Logger in test files -- remove and fix
3. Check `internal/integration_test.go` and `internal/middleware/integration_test.go` for references to deleted middleware functions (`RequestLogger`, `RequestLoggerWithConfig`) -- remove or update these tests

**Constructor signature changes:**

Tests that create usecases/repos/controllers directly will need updated constructor calls to include the new `zerolog.Logger` parameter. For test files, create a no-op logger:
```go
testLogger := zerolog.Nop()
```
Pass `testLogger` to any constructor that now requires a `zerolog.Logger`.

Run `go test ./...` after updating each test file. Fix any failures before moving to the next file.
  </action>
  <verify>
    `go test ./...` passes with zero failures. `grep -rn '"success".*true\|"success".*false' internal/controller/http/*_test.go` returns zero matches (all assertions updated to use "status"). `grep -rn "internal/logger" --include="*_test.go" .` returns zero matches.
  </verify>
  <done>
    All test files use `"status": "success"` / `"status": "error"` assertions instead of `"success": true/false`. All test imports are valid (no references to deleted packages). All test constructors pass required zerolog.Logger parameter. `go test ./...` passes with zero failures.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./...` passes with zero failures
3. `grep -rn '"log"' --include="*.go" . | grep -v _test.go | grep -v vendor | grep -v "zerolog"` returns zero matches
4. `grep -rn "helper\.NewLogger\|helper\.Logger" --include="*.go" .` returns zero matches
5. `ls internal/helper/logger.go` fails (file deleted)
6. `grep -rn '"success".*true\|"success".*false' --include="*_test.go" .` returns zero matches
7. `grep -rn "internal/logger" --include="*.go" .` returns zero matches (package fully removed)
</verification>

<success_criteria>
- LOG-01 complete: Zero stdlib log calls in production code; all logging uses zerolog
- Both custom logger packages deleted (internal/logger/ and internal/helper/logger.go)
- All components receive zerolog.Logger via dependency injection (not global state)
- All test assertions match the new response envelope format
- All tests pass
- Phase 3 success criteria #1 met: "Zero stdlib log.* calls remain in the codebase"
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-quality-standardization/03-03-SUMMARY.md`
</output>
