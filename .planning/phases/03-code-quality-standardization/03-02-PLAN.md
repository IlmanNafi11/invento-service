---
phase: 03-code-quality-standardization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/controller/http/auth_controller.go
  - internal/controller/http/user_controller.go
  - internal/controller/http/project_controller.go
  - internal/controller/http/modul_controller.go
  - internal/controller/http/tus_controller.go
  - internal/controller/http/tus_modul_controller.go
  - internal/controller/http/tus_helpers.go
  - internal/controller/http/statistic_controller.go
  - internal/controller/http/health_controller.go
  - internal/controller/http/role_controller.go
  - internal/usecase/project_usecase.go
  - internal/usecase/modul_usecase.go
  - internal/usecase/tus_upload_usecase.go
  - internal/usecase/tus_modul_usecase.go
  - internal/usecase/auth_usecase.go
  - internal/usecase/repo/modul_repository.go
  - internal/usecase/repo/project_repository.go
  - internal/helper/file.go
  - internal/errors/errors.go
autonomous: true

must_haves:
  truths:
    - "Every controller error response call (SendErrorResponse, SendBadRequest, SendAppError, etc.) is immediately followed by a return statement"
    - "All file operation errors (modul delete, project delete, cleanup) are checked and logged or returned, not silently ignored"
    - "All usecase and repository errors are wrapped with fmt.Errorf('ServiceName.MethodName: %w', err) for traceability"
    - "File size formatting logic exists in exactly one function (no duplicates)"
  artifacts:
    - path: "internal/controller/http/auth_controller.go"
      provides: "Audited error handling with returns after every error response"
    - path: "internal/controller/http/modul_controller.go"
      provides: "Audited error handling with returns after every error response"
    - path: "internal/controller/http/tus_controller.go"
      provides: "Audited error handling with returns after every error response"
    - path: "internal/controller/http/tus_modul_controller.go"
      provides: "Audited error handling with returns after every error response"
    - path: "internal/helper/file.go"
      provides: "Single FormatFileSize function, no duplicate implementations"
  key_links:
    - from: "internal/usecase/project_usecase.go"
      to: "file operation errors"
      via: "error checking after os.Remove/os.RemoveAll calls"
      pattern: "if err.*:=.*os\\.(Remove|RemoveAll)"
    - from: "internal/usecase/modul_usecase.go"
      to: "file operation errors"
      via: "error checking after file deletion calls"
      pattern: "fmt\\.Errorf.*Usecase\\."
    - from: "internal/controller/http/tus_controller.go"
      to: "helper.SendAppError"
      via: "return after every error response"
      pattern: "return.*Send(AppError|Error|InternalError|BadRequest)"
---

<objective>
Audit and fix all error handling patterns across controllers, usecases, and repositories. Ensure every error response has a return statement, every file operation error is properly handled, all errors are wrapped with ServiceName.MethodName context, and duplicate code (file size formatting) is consolidated.

Purpose: Fix ERR-01 (missing returns after error responses), ERR-02 (ignored file operation errors), and establish consistent error wrapping for traceability. These are safety-critical fixes that prevent fall-through execution after errors.
Output: All controllers have correct return-after-error patterns. All file operation errors are checked. All errors include ServiceName.MethodName context wrapping.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-quality-standardization/03-RESEARCH.md
@.planning/phases/03-code-quality-standardization/03-CONTEXT.md
@internal/controller/base/controller.go
@internal/errors/errors.go
@internal/helper/response.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and fix controller error handling (return-after-error) and deduplicate file size formatting</name>
  <files>
    internal/controller/http/auth_controller.go
    internal/controller/http/user_controller.go
    internal/controller/http/project_controller.go
    internal/controller/http/modul_controller.go
    internal/controller/http/tus_controller.go
    internal/controller/http/tus_modul_controller.go
    internal/controller/http/tus_helpers.go
    internal/controller/http/statistic_controller.go
    internal/controller/http/health_controller.go
    internal/controller/http/role_controller.go
    internal/helper/file.go
  </files>
  <action>
**Controller audit (ERR-01):**

For EACH controller file in `internal/controller/http/`, perform this audit:
1. Read the entire file
2. Find every call to `helper.Send*Response()`, `helper.SendAppError()`, `ctrl.Send*()`, `bc.Send*()`, or any function that sends an HTTP error response
3. Verify that each error response call is preceded by `return` (i.e., the function returns the result of the send call)
4. If a send call is NOT returned, add `return` before it. The pattern should be:
   ```go
   return helper.SendErrorResponse(c, ...)
   // or
   return ctrl.SendInternalError(c)
   ```
5. Pay special attention to:
   - `auth_controller.go`: Uses `helper.NewLogger()` for logging -- leave the logger calls for Plan 03 to handle, but fix any missing returns
   - `tus_controller.go` and `tus_modul_controller.go`: These have the most error handling paths (9 and 17 helper.Send* calls respectively)
   - `tus_helpers.go`: Has 12 helper.Send* calls -- audit each one

Run `go build ./...` after each controller file change. Do NOT batch changes.

**File size deduplication:**

In `internal/helper/file.go`:
1. Find the three duplicate file size formatting implementations (approximately lines 85-100, 264-281, 339-352 per research)
2. Keep the `FormatFileSize()` function (the named exported one around line 264-281)
3. Replace the other two inline implementations with calls to `FormatFileSize()`
4. Run `go build ./...` and `go test ./internal/helper/...` after the change
  </action>
  <verify>
    `go build ./...` compiles. Run this audit command to verify no missing returns:
    ```
    grep -n "helper\.Send\|ctrl\.Send\|bc\.Send" internal/controller/http/*.go | grep -v "return" | grep -v "//" | grep -v "_test.go"
    ```
    The output should show zero lines where a Send* call is not part of a return statement (excluding comments and test files). Also verify `go test ./internal/controller/... ./internal/helper/...` passes.
  </verify>
  <done>
    Every error response call in every controller is preceded by `return`. File size formatting exists in exactly one exported function `FormatFileSize()` with no duplicate inline implementations. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add consistent error wrapping in usecases and repositories, fix ignored file operation errors</name>
  <files>
    internal/usecase/project_usecase.go
    internal/usecase/modul_usecase.go
    internal/usecase/tus_upload_usecase.go
    internal/usecase/tus_modul_usecase.go
    internal/usecase/auth_usecase.go
    internal/usecase/repo/modul_repository.go
    internal/usecase/repo/project_repository.go
    internal/errors/errors.go
  </files>
  <action>
**Error wrapping (user decision: `fmt.Errorf("ServiceName.MethodName: %w", err)`):**

For each usecase file:
1. Read the file and find every `return ..., err` or `return nil, err` where the error is returned unwrapped
2. Wrap each error with the format: `fmt.Errorf("UsecaseName.MethodName: %w", err)`
   - Example: In `project_usecase.go`, a method `Delete` returning unwrapped err becomes:
     `return fmt.Errorf("ProjectUsecase.Delete: %w", err)`
3. For errors that are already wrapped or are AppError types (created via `apperrors.NewNotFoundError()` etc.), do NOT double-wrap them
4. Apply the same pattern in repository files: `fmt.Errorf("RepoName.MethodName: %w", err)`

**Ignored file operation errors (ERR-02):**

Per user decision: "selective based on severity -- critical errors (delete failure) must be checked and logged, minor cleanup errors (temp file) may be ignored."

1. In `internal/usecase/project_usecase.go`: Find file deletion calls (e.g., `os.Remove`, `os.RemoveAll`, or file manager delete calls). For critical ones (deleting a user's project file), check the error and return it wrapped. For example:
   ```go
   if err := os.RemoveAll(projectPath); err != nil {
       return fmt.Errorf("ProjectUsecase.Delete: failed to remove project files: %w", err)
   }
   ```

2. In `internal/usecase/modul_usecase.go` or `internal/usecase/tus_modul_usecase.go`: Same pattern for modul file deletions.

3. In `internal/usecase/tus_upload_usecase.go`: Check for ignored errors in upload completion/cleanup. Critical: file move/rename errors. Minor (can be ignored with comment): temp file cleanup.

4. For errors that may be ignored (minor cleanup), add a comment explaining why:
   ```go
   // Cleanup error for temp file is non-critical; log in future zerolog migration
   _ = os.Remove(tempPath)
   ```

**Sentinel errors (Claude's discretion):**

In `internal/errors/errors.go`, add sentinel errors for repository-level translation:
```go
var (
    ErrRecordNotFound = errors.New("record not found")
    ErrDuplicateEntry = errors.New("duplicate entry")
)
```
Update `internal/usecase/repo/modul_repository.go` and `internal/usecase/repo/project_repository.go` to use these sentinel errors when translating `gorm.ErrRecordNotFound`, instead of directly creating AppError in repos. The usecase layer should translate sentinel errors to AppError.

Run `go build ./...` and `go test ./...` after each file change. Do NOT batch.
  </action>
  <verify>
    `go build ./...` compiles. `go test ./...` passes. Run:
    ```
    grep -rn "return.*nil,.*err$" internal/usecase/*.go internal/usecase/repo/*.go | grep -v "test" | grep -v "Errorf" | grep -v "AppError" | grep -v "NewNotFound\|NewValidation\|NewInternal\|NewConflict\|NewForbidden\|NewUnauthorized"
    ```
    This should return minimal matches -- only cases where err is an already-wrapped error or an AppError.
  </verify>
  <done>
    All usecase error returns include `fmt.Errorf("ServiceName.MethodName: %w", err)` wrapping. All critical file operation errors are checked and returned/logged. Sentinel errors `ErrRecordNotFound` and `ErrDuplicateEntry` exist in the errors package. Repository layer uses sentinel errors for GORM error translation. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./...` passes
3. No controller has a Send*Response call without a preceding `return`
4. `grep -rn "return nil, err$" internal/usecase/` returns zero unwrapped errors (all use fmt.Errorf wrapping)
5. File size formatting in `internal/helper/file.go` has exactly one implementation
</verification>

<success_criteria>
- ERR-01: Every controller error response is followed by a return (zero fall-through cases)
- ERR-02: All critical file operation errors are checked (delete failures are not silently ignored)
- Error wrapping: All usecases and repositories use `fmt.Errorf("ServiceName.MethodName: %w", err)` consistently
- Code dedup: FormatFileSize exists once, not three times
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-quality-standardization/03-02-SUMMARY.md`
</output>
