---
phase: 05-deep-architecture-improvements
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - internal/usecase/repo/interfaces.go
  - internal/usecase/repo/role_repository.go
  - internal/usecase/repo/permission_repository.go
  - internal/usecase/repo/role_permission_repository.go
  - internal/usecase/repo/user_repository.go
  - internal/usecase/role_usecase.go
  - internal/usecase/user_usecase.go
  - internal/usecase/test_mocks.go
  - internal/controller/http/role_controller.go
  - internal/controller/http/user_controller.go
  - internal/usecase/role_usecase_test.go
  - internal/usecase/user_usecase_test.go
  - internal/controller/http/role_controller_test.go
  - internal/controller/http/user_controller_test.go
  - internal/usecase/repo/test/role_repository_test.go
  - internal/usecase/repo/role_permission_repository_coverage_test.go
  - internal/helper/middleware.go
  - internal/helper/middleware_test.go
autonomous: true

must_haves:
  truths:
    - "Every RoleRepository, PermissionRepository, and RolePermissionRepository method accepts context.Context as first parameter"
    - "Every UserRepository method accepts context.Context as first parameter"
    - "Every RoleUsecase method accepts context.Context as first parameter"
    - "Every UserUsecase method accepts context.Context as first parameter"
    - "RoleController and UserController extract c.UserContext() and pass it through usecase calls"
    - "Repository implementations use db.WithContext(ctx) for all GORM queries"
    - "Mock methods updated with context.Context parameter"
    - "Test mock.On() calls use mock.Anything for context parameter"
    - "go build ./... compiles with zero errors"
    - "go test ./... -count=1 passes"
  artifacts:
    - path: "internal/usecase/repo/interfaces.go"
      provides: "Updated RoleRepository, PermissionRepository, RolePermissionRepository, UserRepository interfaces with context.Context"
  key_links:
    - from: "internal/controller/http/role_controller.go"
      to: "internal/usecase/role_usecase.go"
      via: "c.UserContext() passed as ctx to usecase methods"
      pattern: "c\\.UserContext\\(\\)"
    - from: "internal/usecase/role_usecase.go"
      to: "internal/usecase/repo/role_repository.go"
      via: "ctx passed through to repository methods"
      pattern: "ctx,"
    - from: "internal/usecase/repo/role_repository.go"
      to: "GORM db.WithContext(ctx)"
      via: "repository uses db.WithContext(ctx) for all queries"
      pattern: "db\\.WithContext\\(ctx\\)"
---

<objective>
Add context.Context propagation to Role/Permission and User domains: interfaces, implementations, controllers, mocks, and tests.

Purpose: Enable proper timeout/cancellation support for the Role and User domains, which are the foundation for other domains.
Output: All Role/Permission and User layer methods accept context.Context as first parameter.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deep-architecture-improvements/05-RESEARCH.md
@.planning/phases/05-deep-architecture-improvements/05-02-SUMMARY.md

@internal/usecase/repo/interfaces.go
@internal/usecase/role_usecase.go
@internal/usecase/user_usecase.go
@internal/controller/http/role_controller.go
@internal/controller/http/user_controller.go
@internal/usecase/test_mocks.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context.Context to Role/Permission interfaces, implementations, and controller</name>
  <files>
    internal/usecase/repo/interfaces.go
    internal/usecase/repo/role_repository.go
    internal/usecase/repo/permission_repository.go
    internal/usecase/repo/role_permission_repository.go
    internal/usecase/role_usecase.go
    internal/usecase/test_mocks.go
    internal/controller/http/role_controller.go
    internal/usecase/role_usecase_test.go
    internal/controller/http/role_controller_test.go
    internal/usecase/repo/test/role_repository_test.go
    internal/usecase/repo/role_permission_repository_coverage_test.go
  </files>
  <action>
    Process Role/Permission domain in this order:

    1. **Repository interfaces** (`internal/usecase/repo/interfaces.go`):
       - Add `import "context"`
       - Add `ctx context.Context` as first parameter to EVERY method in:
         - RoleRepository (6 methods: Create, GetByID, GetByName, Update, Delete, GetAll)
         - PermissionRepository (7 methods: Create, GetByID, GetByResourceAndAction, GetAllByResourceActions, GetAll, GetAvailablePermissions, BulkCreate)
         - RolePermissionRepository (5 methods: Create, BulkCreate, GetByRoleID, DeleteByRoleID, GetPermissionsForRole)

    2. **Repository implementations**:
       - `role_repository.go`: Add `ctx context.Context` to each method signature. Wrap every `r.db.` call with `.WithContext(ctx)` -- e.g., `r.db.WithContext(ctx).Create(&role)`.
       - `permission_repository.go`: Same pattern.
       - `role_permission_repository.go`: Same pattern (check file name -- may be in role_repository.go or separate).

    3. **Usecase interface + implementation** (`role_usecase.go`):
       - Add `ctx context.Context` as first parameter to the RoleUsecase interface (all methods).
       - Update the implementation to accept ctx and pass it through to all repository calls.
       - Add `import "context"` if not present.

    4. **Controller** (`role_controller.go`):
       - At the start of each handler: `ctx := c.UserContext()`
       - Pass ctx to all usecase method calls.
       - Where the controller currently handles errors with `errors.As(err, &appErr)` blocks, simplify to `return err` since the centralized ErrorHandler (from Plan 05-01) will handle it. But ONLY do this for error paths that return AppError. Keep local handling for non-AppError cases (validation errors, query parsing).

    5. **Mock updates** (`test_mocks.go`):
       - Update MockRoleRepository, MockPermissionRepository, MockRolePermissionRepository methods to accept `ctx context.Context`.
       - Update `m.Called(...)` to include ctx.
       - Update MockRoleUsecase methods similarly.

    6. **Test updates**:
       - `role_usecase_test.go`: Update all `mockRepo.On("MethodName", ...)` to include `mock.Anything` as first argument (for context). Update all direct method calls to pass `context.Background()`.
       - `role_controller_test.go`: Tests use HTTP requests, so no change needed to test setup -- the controller internally extracts context from Fiber.
       - `role_repository_test.go` and `role_permission_repository_coverage_test.go`: Update direct repo calls to pass `context.Background()`.

    7. Run `go build ./...` to verify compilation before proceeding to Task 2.
  </action>
  <verify>
    `go build ./...` passes.
    `go test ./internal/usecase/... -count=1 -run Role` passes.
    `go test ./internal/controller/http/... -count=1 -run Role` passes.
    `grep -c "ctx context.Context" internal/usecase/repo/interfaces.go` shows 18 (Role=6 + Permission=7 + RolePermission=5).
  </verify>
  <done>
    All Role/Permission repository, usecase, and controller methods accept context.Context. GORM queries use WithContext(ctx). Mocks and tests updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add context.Context to User interfaces, implementations, and controller</name>
  <files>
    internal/usecase/repo/interfaces.go
    internal/usecase/repo/user_repository.go
    internal/usecase/user_usecase.go
    internal/usecase/test_mocks.go
    internal/controller/http/user_controller.go
    internal/usecase/user_usecase_test.go
    internal/controller/http/user_controller_test.go
    internal/helper/middleware.go
    internal/helper/middleware_test.go
  </files>
  <action>
    Process User domain:

    1. **Repository interface** (`interfaces.go`):
       - Add `ctx context.Context` to all 12 UserRepository methods (GetByEmail, GetByID, GetByIDs, Create, GetAll, GetProfileWithCounts, GetUserFiles, UpdateRole, UpdateProfile, Delete, GetByRoleID, BulkUpdateRole).

    2. **Repository implementation** (`user_repository.go`):
       - Add `ctx context.Context` to each method. Use `r.db.WithContext(ctx)` for all GORM queries.

    3. **Usecase interface + implementation** (`user_usecase.go`):
       - Add `ctx context.Context` to all UserUsecase interface methods.
       - Update implementation to pass ctx to repository calls.
       - Note: UserUsecase methods that call RoleRepository methods (already updated in Task 1) must pass ctx.

    4. **Controller** (`user_controller.go`):
       - Add `ctx := c.UserContext()` at start of each handler.
       - Pass ctx to usecase calls.
       - Simplify AppError handling to `return err` where appropriate.

    5. **Mock updates** (`test_mocks.go`):
       - Update MockUserRepository and MockUserUsecase methods.

    6. **Test updates**:
       - `user_usecase_test.go`: Add `mock.Anything` for context in mock.On() calls. Pass `context.Background()` to direct usecase calls.
       - `user_controller_test.go`: Controller tests use HTTP; no setup changes needed.

    7. **Middleware updates**:
       - `helper/middleware.go`: The auth middleware calls `userRepo.GetByID(...)`. Update to pass context: `userRepo.GetByID(c.UserContext(), userID)`.
       - `helper/middleware_test.go`: Update mock.On() calls for GetByID to include `mock.Anything`.

    8. Run `go build ./...` and `go test ./... -count=1`.
  </action>
  <verify>
    `go build ./...` passes.
    `go test ./... -count=1` passes (full suite, not just User tests -- middleware changes affect everything).
    `grep -c "ctx context.Context" internal/usecase/repo/interfaces.go` shows 30 (18 from Task 1 + 12 User).
  </verify>
  <done>
    All User repository, usecase, and controller methods accept context.Context. Middleware updated. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./... -count=1` passes
3. All Role/Permission/User repo and usecase interfaces have context.Context as first param
4. All implementations use db.WithContext(ctx)
5. Controllers use c.UserContext()
6. All mocks and tests updated
</verification>

<success_criteria>
- 30 repository interface methods (18 Role/Permission + 12 User) have context.Context
- RoleUsecase and UserUsecase interfaces have context.Context on all methods
- RoleController and UserController use c.UserContext()
- All GORM queries use WithContext(ctx)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-deep-architecture-improvements/05-03-SUMMARY.md`
</output>
