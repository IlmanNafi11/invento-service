---
phase: 05-deep-architecture-improvements
plan: 08
type: execute
wave: 7
depends_on: ["05-06", "05-07"]
files_modified:
  - "internal/**/*_test.go"
autonomous: true

must_haves:
  truths:
    - "Tests that use isolated mocks call t.Parallel() at the start"
    - "Integration tests with per-call SetupTestDatabase() call t.Parallel()"
    - "Tests sharing mutable state (global variables, shared fixtures) do NOT call t.Parallel()"
    - "No Go source file in the project exceeds 500 lines (excluding clients/go/)"
    - "go test ./... -count=1 passes"
    - "go test ./... -count=1 -race passes (no race conditions from parallelization)"
  artifacts: []
  key_links: []
---

<objective>
Add t.Parallel() to all tests that can safely run in parallel, and perform final 500-line enforcement verification across all source and test files.

Purpose: Maximize test execution speed and verify the 500-line limit is enforced project-wide, completing all Phase 5 success criteria.
Output: Parallelized test suite, verified 500-line compliance.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deep-architecture-improvements/05-RESEARCH.md
@.planning/phases/05-deep-architecture-improvements/05-06-SUMMARY.md
@.planning/phases/05-deep-architecture-improvements/05-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add t.Parallel() to all safe test functions</name>
  <files>
    internal/**/*_test.go
  </files>
  <action>
    Add `t.Parallel()` as the first line in test functions that can safely run in parallel. Per locked decision: "aggressive test parallelization -- all tests that don't share mutable state should be parallelized."

    **Safe to parallelize (add t.Parallel()):**
    - Unit tests using mock objects (each test creates its own mocks)
    - Tests using per-test `SetupTestDatabase()` (creates isolated in-memory SQLite per call)
    - Table-driven tests where each subtest has its own setup
    - Tests that only read shared fixtures (no mutation)

    **NOT safe to parallelize (do NOT add t.Parallel()):**
    - Tests that modify global variables (package-level vars)
    - Tests that share a database connection across subtests
    - Tests that modify shared file system paths
    - Tests that use `os.Setenv()` / `t.Setenv()` (environment is process-global)
    - Integration tests that share a Fiber app instance

    **Process:**
    1. For each test package, enumerate all test functions.
    2. For each function, determine if it uses:
       - Mock objects only -> SAFE
       - Per-test DB setup -> SAFE
       - Shared state -> NOT SAFE
       - `os.Setenv` / `t.Setenv` -> NOT SAFE
       - Global Fiber app -> NOT SAFE
    3. Add `t.Parallel()` immediately after the function signature for safe tests:
       ```go
       func TestUserUsecase_GetProfile_Success(t *testing.T) {
           t.Parallel()
           // ... rest of test
       }
       ```
    4. For table-driven tests with subtests, add `t.Parallel()` to BOTH the parent test AND each subtest:
       ```go
       func TestUserUsecase_GetProfile(t *testing.T) {
           t.Parallel()
           tests := []struct{ ... }{ ... }
           for _, tt := range tests {
               t.Run(tt.name, func(t *testing.T) {
                   t.Parallel()
                   // ... test body
               })
           }
       }
       ```
       NOTE: For parallel subtests, capture the loop variable: `tt := tt` before `t.Run` (or use Go 1.22+ loop variable semantics if available).

    5. Process packages in this order (matching dependency order):
       - internal/errors/ (standalone, no deps)
       - internal/dto/ (standalone)
       - internal/domain/ (standalone)
       - internal/httputil/ (depends on dto)
       - internal/storage/ (standalone)
       - internal/usecase/repo/test/ (uses DB)
       - internal/usecase/ (uses mocks)
       - internal/controller/http/ (uses mocks + Fiber)
       - internal/middleware/ (uses Fiber)
       - internal/helper/ (mixed)
       - internal/app/ (integration, likely NOT safe)
       - internal/ (integration tests, likely NOT safe)

    6. After adding t.Parallel() to each package, run that package's tests to verify no race conditions:
       `go test ./internal/{package}/... -count=1 -race`

    7. Final full-suite verification:
       `go test ./... -count=1 -race`
  </action>
  <verify>
    `go test ./... -count=1` passes.
    `go test ./... -count=1 -race` passes (no race conditions).
    `grep -rl "t\.Parallel()" internal/ --include="*_test.go" | wc -l` shows significant number of test files with t.Parallel().
    `grep -c "t\.Parallel()" internal/ -r --include="*_test.go"` shows many test functions parallelized.
  </verify>
  <done>
    All safe tests call t.Parallel(). No race conditions detected. Test suite runs faster due to parallelization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final 500-line enforcement and Phase 5 verification</name>
  <files></files>
  <action>
    1. **Verify no source file exceeds 500 lines** (excluding client library):
       ```bash
       find . -name "*.go" -not -path "./clients/*" -not -path "./vendor/*" -exec wc -l {} \; | awk '$1 > 500 {print}'
       ```
       Expected: ZERO files over 500 lines.

    2. If any files are over 500 lines, split them following the patterns established in Plans 05-06/05-07.

    3. **Verify all Phase 5 success criteria:**
       - SC1: Every repository, usecase, and controller interface method accepts context.Context
         ```bash
         grep "^\t[A-Z]" internal/usecase/repo/interfaces.go | grep -v "ctx context.Context" | grep -v "//"
         ```
         Expected: empty

       - SC2: Route registration is split into domain-specific files
         ```bash
         grep -c "func register" internal/app/routes.go
         ```
         Expected: 7 register functions

       - SC3: No Go source file exceeds 500 lines
         ```bash
         find . -name "*.go" -not -path "./clients/*" -not -path "./vendor/*" -exec wc -l {} \; | awk '$1 > 500' | wc -l
         ```
         Expected: 0

       - SC4: Test files organized by concern, all under 500 lines, tests pass
         ```bash
         go test ./... -count=1
         ```
         Expected: all pass

    4. **Final regression check:**
       ```bash
       go build ./...
       go vet ./...
       go test ./... -count=1 -race
       ```

    5. If any issues found, fix them in this task.
  </action>
  <verify>
    `go build ./...` passes.
    `go vet ./...` passes.
    `go test ./... -count=1` passes.
    `go test ./... -count=1 -race` passes.
    `find . -name "*.go" -not -path "./clients/*" -not -path "./vendor/*" -exec wc -l {} \; | awk '$1 > 500' | wc -l` returns 0.
    All 4 Phase 5 success criteria verified.
  </verify>
  <done>
    Phase 5 complete. All success criteria verified: (1) context.Context in all interface methods, (2) modular route registration, (3) no file over 500 lines, (4) organized tests passing.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go vet ./...` passes
3. `go test ./... -count=1` passes
4. `go test ./... -count=1 -race` passes
5. Zero source files over 500 lines (excluding clients/)
6. All 4 Phase 5 success criteria explicitly verified
</verification>

<success_criteria>
- All safe tests use t.Parallel()
- No race conditions detected
- No source or test file exceeds 500 lines
- All Phase 5 success criteria verified:
  1. Every interface method accepts context.Context
  2. Route registration is modular
  3. No file exceeds 500 lines
  4. Tests organized and passing
</success_criteria>

<output>
After completion, create `.planning/phases/05-deep-architecture-improvements/05-08-SUMMARY.md`
</output>
