---
phase: 05-deep-architecture-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/dto/response.go
  - internal/dto/mapper.go
  - internal/domain/response.go
  - internal/httputil/response.go
  - internal/httputil/pagination.go
  - internal/httputil/validator.go
  - internal/httputil/response_test.go
  - internal/httputil/pagination_test.go
  - internal/httputil/response_coverage_test.go
  - internal/middleware/validation.go
  - internal/middleware/validation_test.go
  - internal/middleware/integration_test.go
  - internal/integration_test.go
  - internal/app/server.go
  - internal/app/routes.go
  - internal/app/server_test.go
  - internal/controller/base/controller.go
  - docs/docs.go
  - docs/swagger.json
  - docs/swagger.yaml
autonomous: true

must_haves:
  truths:
    - "jinzhu/copier is installed and available as a dependency"
    - "Response envelope types (BaseResponse, SuccessResponse, ErrorResponse, PaginationData, ListData, ValidationError) live in internal/dto/response.go, not in internal/domain/response.go"
    - "Route registration uses domain-specific standalone register functions in internal/app/routes.go"
    - "Fiber ErrorHandler centrally handles *apperrors.AppError mapping to HTTP responses"
    - "go build ./... compiles with zero errors"
    - "go test ./... -count=1 passes"
  artifacts:
    - path: "internal/dto/response.go"
      provides: "Response envelope types (BaseResponse, SuccessResponse, ErrorResponse, PaginationData, ListData, ValidationError)"
    - path: "internal/app/routes.go"
      provides: "Domain-specific route registration functions (registerAuthRoutes, registerUserRoutes, etc.)"
    - path: "internal/dto/mapper.go"
      provides: "Shared copier-based mapping utilities"
  key_links:
    - from: "internal/httputil/response.go"
      to: "internal/dto/response.go"
      via: "import dto package for BaseResponse, SuccessResponse, ErrorResponse"
      pattern: "dto\\.BaseResponse|dto\\.SuccessResponse|dto\\.ErrorResponse"
    - from: "internal/app/server.go"
      to: "internal/app/routes.go"
      via: "calls registerAuthRoutes, registerUserRoutes, etc."
      pattern: "register\\w+Routes"
    - from: "internal/app/server.go"
      to: "internal/errors"
      via: "Fiber ErrorHandler uses errors.As for AppError mapping"
      pattern: "errors\\.As.*appErr"
---

<objective>
Install jinzhu/copier for struct mapping, migrate response envelope types from domain/ to dto/, extract route registration into domain-specific functions in routes.go, and add centralized error-to-HTTP mapping in Fiber ErrorHandler.

Purpose: Establish the infrastructure foundation that all subsequent context propagation and DTO migration plans depend on.
Output: copier available, response types in dto/, routes.go with register functions, centralized ErrorHandler.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deep-architecture-improvements/05-RESEARCH.md

@internal/domain/response.go
@internal/dto/common.go
@internal/dto/request.go
@internal/httputil/response.go
@internal/httputil/pagination.go
@internal/app/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install copier and migrate response envelope types to dto</name>
  <files>
    go.mod
    go.sum
    internal/dto/response.go
    internal/dto/mapper.go
    internal/domain/response.go
    internal/httputil/response.go
    internal/httputil/pagination.go
    internal/httputil/validator.go
    internal/httputil/response_test.go
    internal/httputil/pagination_test.go
    internal/httputil/response_coverage_test.go
    internal/middleware/validation.go
    internal/middleware/validation_test.go
    internal/middleware/integration_test.go
    internal/integration_test.go
    internal/controller/base/controller.go
    docs/docs.go
    docs/swagger.json
    docs/swagger.yaml
  </files>
  <action>
    1. Run `go get github.com/jinzhu/copier` to install copier.

    2. Move the following types from `internal/domain/response.go` to `internal/dto/response.go` (append to existing file):
       - `BaseResponse`
       - `SuccessResponse`
       - `ErrorResponse`
       - `PaginationData`
       - `ListData`
       - `ValidationError`

    3. Delete `internal/domain/response.go` entirely (it will only contain the types being moved, nothing else remains).

    4. Create `internal/dto/mapper.go` with a thin wrapper around copier for project-wide consistent mapping:
       ```go
       package dto

       import "github.com/jinzhu/copier"

       // CopyStruct copies fields from src to dst using jinzhu/copier.
       // Returns error if field copy fails.
       func CopyStruct(dst, src interface{}) error {
           return copier.Copy(dst, src)
       }
       ```

    5. Update ALL consumers of the moved types. Replace `domain.BaseResponse` -> `dto.BaseResponse`, `domain.SuccessResponse` -> `dto.SuccessResponse`, etc. across all files. Key files to update:
       - `internal/httputil/response.go` (import dto instead of domain for response types)
       - `internal/httputil/pagination.go` (PaginationData reference)
       - `internal/httputil/validator.go` (ValidationError reference)
       - `internal/middleware/validation.go` (response types)
       - `internal/controller/base/controller.go` (if it references response types)
       - All test files referencing these types
       - Swagger docs (`docs/docs.go`, `docs/swagger.json`, `docs/swagger.yaml`) -- update type references

    6. Run `go build ./...` to verify compilation.

    IMPORTANT: Do NOT move domain-specific request/response types yet (UserListData, RoleCreateRequest, etc.). Only move the shared response envelope types.

    NOTE: `domain/response_test.go` tests the response types. Move or update the tests to work with the dto package location.
  </action>
  <verify>
    `go build ./...` passes with zero errors.
    `grep -rn "domain\.BaseResponse\|domain\.SuccessResponse\|domain\.ErrorResponse\|domain\.PaginationData\|domain\.ListData\|domain\.ValidationError" internal/ --include="*.go"` returns zero results (excluding docs/).
    `internal/domain/response.go` no longer exists.
    `internal/dto/response.go` contains BaseResponse, SuccessResponse, ErrorResponse, PaginationData, ListData, ValidationError.
  </verify>
  <done>
    copier installed in go.mod, response envelope types live in dto/response.go, all consumers updated, no compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract route registration into domain-specific functions</name>
  <files>
    internal/app/server.go
    internal/app/routes.go
  </files>
  <action>
    1. Read `internal/app/server.go` and identify the route registration block (all `api.Group(...)` and route `.Get()/.Post()/.Patch()/.Delete()` calls).

    2. Create `internal/app/routes.go` with standalone register functions per domain (per locked decision: standalone functions, NOT controller methods):
       - `registerAuthRoutes(api fiber.Router, ...)` -- receives auth controller and middleware deps
       - `registerUserRoutes(api fiber.Router, ...)` -- receives user controller, auth middleware, casbin enforcer
       - `registerRoleRoutes(api fiber.Router, ...)` -- receives role controller, user controller (for role deletion user check), auth middleware, casbin enforcer
       - `registerProjectRoutes(api fiber.Router, ...)` -- receives project controller, TUS controller, auth middleware, casbin enforcer, config
       - `registerModulRoutes(api fiber.Router, ...)` -- receives modul controller, TUS modul controller, auth middleware, casbin enforcer, config
       - `registerStatisticRoutes(api fiber.Router, ...)` -- receives statistic controller, auth middleware
       - `registerMonitoringRoutes(api fiber.Router, ...)` -- receives health controller (no auth needed for health)

    3. Each register function receives the router group and applies its OWN middleware (auth, RBAC) per-group -- no global middleware application (per locked decision).

    4. In `server.go`, replace the route registration block with calls to the register functions:
       ```go
       api := app.Group("/api/v1")
       registerAuthRoutes(api, authController, supabaseAuthService, userRepo, cookieHelper)
       registerUserRoutes(api, userController, authMiddleware, casbinEnforcer)
       // ... etc
       ```

    5. Verify that `server.go` and `routes.go` are both under 500 lines.

    NOTE: Examine server.go carefully to determine what dependencies each register function needs. The function parameters should exactly match what the route group requires -- nothing more.
  </action>
  <verify>
    `go build ./...` passes.
    `go test ./internal/app/... -count=1` passes (server tests still work).
    `wc -l internal/app/routes.go internal/app/server.go` shows both under 500 lines.
    `grep -c "registerAuthRoutes\|registerUserRoutes\|registerRoleRoutes\|registerProjectRoutes\|registerModulRoutes\|registerStatisticRoutes\|registerMonitoringRoutes" internal/app/routes.go` shows 7 function definitions.
  </verify>
  <done>
    Route registration extracted into 7 domain-specific functions in routes.go. server.go calls them. Both files under 500 lines.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add centralized error-to-HTTP mapping in Fiber ErrorHandler</name>
  <files>
    internal/app/server.go
  </files>
  <action>
    1. In `internal/app/server.go`, update the Fiber app config `ErrorHandler` to centrally handle `*apperrors.AppError`:
       ```go
       ErrorHandler: func(c *fiber.Ctx, err error) error {
           // Handle AppError types centrally
           var appErr *apperrors.AppError
           if errors.As(err, &appErr) {
               return httputil.SendAppError(c, appErr)
           }

           // Handle Fiber errors
           var fiberErr *fiber.Error
           if errors.As(err, &fiberErr) {
               if fiberErr.Code == fiber.StatusNotFound {
                   return httputil.SendNotFoundResponse(c, "Endpoint tidak ditemukan")
               }
               return httputil.SendErrorResponse(c, fiberErr.Code, fiberErr.Message, nil)
           }

           // TUS protocol errors (preserve existing behavior)
           tusVersion := c.Get("Tus-Resumable")
           if tusVersion != "" && (c.Method() == "PATCH" || c.Method() == "HEAD" || c.Method() == "DELETE") {
               c.Set("Tus-Resumable", cfg.Upload.TusVersion)
               return c.SendStatus(fiber.StatusInternalServerError)
           }

           // Default: internal server error
           appLogger.Error().Str("path", c.Path()).Str("method", c.Method()).Err(err).Msg("unhandled error")
           return httputil.SendInternalServerErrorResponse(c)
       },
       ```

    2. Ensure necessary imports are present (`errors`, `apperrors`, `httputil`).

    3. Do NOT simplify controller error handling patterns yet -- that happens in subsequent context propagation plans (05-03 through 05-05). The ErrorHandler is additive: it catches errors that "fall through" from controllers. Controllers can start returning errors instead of handling them locally, but this transition happens incrementally in later plans.

    4. Run `go build ./...` and `go test ./... -count=1` to verify no regression.
  </action>
  <verify>
    `go build ./...` passes.
    `go test ./... -count=1` passes.
    `grep -A 5 "ErrorHandler:" internal/app/server.go` shows the centralized AppError handling.
  </verify>
  <done>
    Fiber ErrorHandler centrally maps *apperrors.AppError to HTTP responses. All existing behavior preserved. Controllers can now optionally return errors directly.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./... -count=1` passes
3. `internal/dto/response.go` contains all response envelope types
4. `internal/domain/response.go` no longer exists
5. `internal/app/routes.go` contains 7 register functions
6. `internal/app/server.go` calls all register functions
7. Both server.go and routes.go are under 500 lines
8. Fiber ErrorHandler handles AppError centrally
</verification>

<success_criteria>
- copier installed and importable
- Response envelope types moved from domain to dto with zero remaining references to domain.BaseResponse etc.
- Route registration modularized into domain-specific functions
- Centralized ErrorHandler in place
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-deep-architecture-improvements/05-01-SUMMARY.md`
</output>
