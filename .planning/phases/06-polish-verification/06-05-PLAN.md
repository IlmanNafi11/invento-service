---
phase: 06-polish-verification
plan: 05
type: execute
wave: 2
depends_on: ["06-03"]
files_modified:
  - docs/swagger.json
  - docs/swagger.yaml
  - docs/docs.go
  - .env.example
autonomous: true

must_haves:
  truths:
    - "swag init generates successfully with all endpoints including TUS"
    - "Swagger UI renders all endpoints when accessed"
    - ".env.example documents every config option from Phases 1-5"
    - "Memory verification procedure is documented with clear pass/fail criteria"
  artifacts:
    - path: "docs/swagger.json"
      provides: "Complete Swagger API specification"
    - path: "docs/swagger.yaml"
      provides: "Complete Swagger API specification (YAML)"
    - path: "docs/docs.go"
      provides: "Generated Swagger Go bindings"
    - path: ".env.example"
      provides: "Complete environment variable documentation"
  key_links:
    - from: "docs/swagger.json"
      to: "internal/controller/http/*.go"
      via: "swag init annotation parsing"
      pattern: "@Router"
---

<objective>
Regenerate Swagger documentation with all newly-annotated endpoints, audit and update .env.example with all configuration options from Phases 1-5, and create a memory verification checklist.

Purpose: Complete the documentation deliverables for Phase 6 and establish the memory verification procedure.
Output: Complete Swagger docs, comprehensive .env.example, memory testing checklist.
</objective>

<execution_context>
@/home/ilmannafi/.claude/get-shit-done/workflows/execute-plan.md
@/home/ilmannafi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-verification/06-RESEARCH.md
@.planning/phases/06-polish-verification/06-03-SUMMARY.md
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate Swagger documentation and verify completeness</name>
  <files>
    docs/swagger.json
    docs/swagger.yaml
    docs/docs.go
  </files>
  <action>
  Regenerate all Swagger documentation using the Taskfile command or direct swag command.

  1. Run `swag init -g cmd/app/main.go --output docs --parseDependency --parseInternal` (this is the command from the existing Taskfile).

  2. After generation, verify completeness:
     - Count total endpoints: `grep -c '"/' docs/swagger.json` or parse the paths object
     - Verify TUS endpoints appear: `grep -c "TUS" docs/swagger.json`
     - Verify GetUsersForRole appears: `grep "GetUsersForRole\|users-for-role\|usersForRole" docs/swagger.json`
     - Verify BulkAssignRole appears: `grep "BulkAssignRole\|bulk-assign\|bulkAssign" docs/swagger.json`

  3. If `swag init` reports any errors (missing types, unresolvable references):
     - Fix the annotations in the controller files
     - Re-run `swag init`
     - Repeat until clean

  4. Verify the generated files exist and are non-empty:
     - `docs/swagger.json` (should be several KB)
     - `docs/swagger.yaml` (should be several KB)
     - `docs/docs.go` (Go bindings)

  5. Run `go build ./...` after regeneration to ensure docs.go compiles correctly.

  Do NOT manually edit docs/swagger.json or docs/swagger.yaml -- they are generated files.
  If swag init fails, fix the source annotations, not the output.
  </action>
  <verify>Run `swag init -g cmd/app/main.go --output docs --parseDependency --parseInternal 2>&1` -- must succeed without errors. Run `go build ./...` -- must pass. Verify endpoint count: `python3 -c "import json; d=json.load(open('docs/swagger.json')); print(f'Endpoints: {sum(len(v) for v in d.get(\"paths\",{}).values())}')"` -- should show 40+ endpoints (29 existing + 22 new).</verify>
  <done>swag init generates without errors. docs/swagger.json contains all endpoints including TUS uploads, GetUsersForRole, and BulkAssignRole. go build passes with generated docs.go.</done>
</task>

<task type="auto">
  <name>Task 2: Audit and update .env.example with all Phase 1-5 config options</name>
  <files>.env.example</files>
  <action>
  Audit the current .env.example against all configuration options used across the codebase. Cross-reference with config/config.go to find every environment variable.

  1. Read `config/config.go` to list ALL env vars loaded by the config package (look for `os.Getenv`, `getEnvAsInt`, `getEnvAsBool`, `getEnvAsFloat64`, `godotenv.Load` patterns).

  2. Read the current `.env.example` and identify any missing variables.

  3. Check if any new config options were added in Phases 1-5 that are not in .env.example:
     - Phase 1: Constants, GOMEMLIMIT, GOGC
     - Phase 2: FIBER_*, DB_MAX_*, ENABLE_PPROF, MEMORY_WARNING_THRESHOLD
     - Phase 3: LOG_LEVEL, LOG_FORMAT, LOG_REQUEST_BODY
     - Phase 4: No new config (architecture restructuring)
     - Phase 5: No new config (context propagation)

  4. Verify the current .env.example has all these sections with correct defaults and descriptions:
     - Application (APP_ENV, APP_NAME, APP_PORT, CORS_*)
     - Database (DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME)
     - Logging (LOG_LEVEL, LOG_FORMAT, LOG_REQUEST_BODY)
     - Upload/TUS (UPLOAD_*, TUS_*)
     - Swagger (SWAGGER_ENABLED)
     - Runtime Memory (GOMEMLIMIT, GOGC)
     - Performance (FIBER_*, DB_MAX_*, DB_CONN_*, ENABLE_PPROF, MEMORY_WARNING_THRESHOLD)
     - Supabase (SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, SUPABASE_ANON_KEY, SUPABASE_JWT_SECRET, SUPABASE_DB_URL)

  5. Add any missing variables with:
     - Clear section headers
     - Default values matching development usage
     - Descriptive comments explaining purpose and valid values
     - Security warnings for secrets

  The current .env.example looks comprehensive already based on earlier phases. This task is primarily a verification pass to catch any gaps.
  </action>
  <verify>Run `grep -oP '[A-Z_]+=\S*' config/config.go | sort` and compare against `grep -oP '^[A-Z_]+=' .env.example | sort` to identify any config vars in code not documented in .env.example. Diff should show zero undocumented variables.</verify>
  <done>.env.example documents every environment variable used by the config package. All sections have clear headers, defaults, and descriptions. No undocumented config options exist.</done>
</task>

<task type="auto">
  <name>Task 3: Create memory verification checklist</name>
  <files>.planning/phases/06-polish-verification/06-MEMORY-VERIFICATION.md</files>
  <action>
  Create a step-by-step memory verification checklist that can be used to manually verify the service stays under the 350MB heap limit during concurrent upload load.

  The checklist should include:

  1. **Prerequisites:**
     - Running PostgreSQL database (or Supabase connection)
     - Service built and running locally
     - ENABLE_PPROF=true in environment
     - 5 test files of 5MB each prepared

  2. **Baseline capture:**
     - Start the service: `go run cmd/app/main.go`
     - Wait 10 seconds for initialization
     - Capture baseline heap: `curl -s http://localhost:6060/debug/pprof/heap > heap_baseline.pb.gz`
     - Check baseline: `go tool pprof -text -inuse_space heap_baseline.pb.gz | head -20`

  3. **Concurrent upload simulation:**
     - Document the exact curl/script commands to run 5 concurrent TUS uploads
     - Each upload: 5MB file, chunked at 1MB
     - Include the TUS protocol flow: POST to create upload -> PATCH to upload chunks -> verify completion

  4. **Peak capture:**
     - During uploads: `curl -s http://localhost:6060/debug/pprof/heap > heap_peak.pb.gz`
     - After uploads: `curl -s http://localhost:6060/debug/pprof/heap > heap_post.pb.gz`

  5. **Verification:**
     - `go tool pprof -text -inuse_space heap_peak.pb.gz | head -20`
     - Pass criteria: inuse_space < 350MB (367,001,600 bytes)
     - `go tool pprof -diff_base=heap_baseline.pb.gz heap_peak.pb.gz` for delta analysis

  6. **Pass/Fail decision:**
     - PASS: heap inuse_space under 350MB during peak load
     - FAIL: heap inuse_space exceeds 350MB

  Note: This is a documentation artifact (per user decision, Claude's discretion on approach). The actual memory test requires a running database and authenticated service, which may not be available in the development environment.
  </action>
  <verify>Verify the file exists and contains all sections: `grep -c "##" .planning/phases/06-polish-verification/06-MEMORY-VERIFICATION.md` should show 6+ sections.</verify>
  <done>Memory verification checklist created with clear prerequisites, step-by-step procedure, capture commands, and pass/fail criteria (350MB heap threshold).</done>
</task>

</tasks>

<verification>
1. `swag init` succeeds without errors
2. docs/swagger.json contains all endpoints (40+ total)
3. `go build ./...` passes
4. .env.example covers all config options
5. Memory verification checklist exists with clear procedure
</verification>

<success_criteria>
- Swagger documentation regenerated with 100% endpoint coverage
- .env.example documents every configuration variable in the codebase
- Memory verification checklist provides actionable steps with pass/fail criteria
- go build passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-verification/06-05-SUMMARY.md`
</output>
